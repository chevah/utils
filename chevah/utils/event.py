# Copyright (c) 2012 Adi Roiban.
# See LICENSE for details.
"""
Events are the basic mechanism for signaling that something specific took
place inside the server/client.

The products have an **event definitions** database.
The event definition is the basic configuration for each event.
Multiple event definitions are grouped using EventGroupDefinition.

The **event definition** is the static part of the event, generated by the
product at startup time.

The **event** itself is the dynamic part, generated by the product at runtime.
The products will **emit** an event.

An event is emitted using emit(ID, DATA).
ID is the unique event definition id. It will be looked in the database to
retrieve a message and other configurations.
DATA is a dictionary with key:values that will be applied for this event.

If the event database is not available (for example at product initialization)
an event can be emitted using emit(ID, MESSAGE). In this case, the event
will be emitted using default configuration.
"""
from twisted.internet import defer
from zope.interface import implements

from chevah.utils.constants import (
    CONFIGURATION_ALL_LOG_ENABLED_GROUPS,
    )
from chevah.utils.exceptions import ChevahException
from chevah.utils.helpers import _
from chevah.utils.interfaces import (
    IEvent,
    IEventDefinition,
    IEventGroupDefinition,
    IEventsDefinition,
    )
from chevah.utils.json_file import JSONFile
from chevah.utils.logger import Logger


class EventGroupDefinition(object):
    """
    The definition for a group of events.

    Events will be attached (tagged) to various groups.
    The EventDefiniton <-> EventGroupDefinition association is done in the
    EventDefinition.

    EventGroupDefinition has the following fields:
     * name
     * description
    """
    implements(IEventGroupDefinition)

    def __init__(self, name, description=None):
        self._name = name
        if description is None:
            description = u'No description.'
        self._description = description

    def __repr__(self):
        return u"EventGroupDefinition(name=%s)" % (self.name)

    @property
    def name(self):
        """
        Return the name of this group.
        """
        return self._name

    @property
    def description(self):
        """
        Return the description of this group.
        """
        return self._description


class EventDefinition(object):
    """
    The definition for a single event.
    """

    implements(IEventDefinition)

    def __init__(self, id, message, groups=None, description=None,
            version_added=None, version_removed=None, data=None
            ):
        self._id = id
        self.message = message
        if groups is None:
            groups = []
        self.groups = groups
        self.description = description
        self.version_added = version_added
        self.version_removed = version_removed
        if data is None:
            data = {}
        self.data = data

    def __repr__(self):
        groups = [group.name for group in self.groups]
        return u"EventDefinition(id=%s, message=%s, groups=%s)" % (
            self.id, self.message, ', '.join(groups))

    @property
    def id(self):
        """
        The raw id of this event.
        """
        return self._id

    @property
    def id_padded(self):
        """
        The padded is as used in documentation and logs.
        """
        if len(self._id) >= 5:
            return self._id
        else:
            return ('0' * (5 - len(self._id))) + self._id

    @property
    def group_names(self):
        """
        Return a list containing names for the attached groups.
        """
        result = [group.name for group in self.groups]
        return result


class Event(object):
    """
    An event as raised by a service.
    """

    implements(IEvent)

    def __init__(self, id, message=None, data=None):
        self.id = id

        if message is None:
            message = ''
        self.message = message

        if data is None:
            data = {}
        self.data = data

    def __repr__(self):
        return u"Event(id=%s, data=%s)" % (self.id, self.data)

    def __str__(self):
        return self.__repr__()


class EventNotFound(Event):
    """
    Event raised when an initial event was not found in the database.
    """
    def __init__(self, event):
        data = event.data.copy()
        data.update({
            'id': event.id,
            'message': event.message,
            })
        message = (
            'Unknown event with id "%(id)s" and message "%(message)s".' % (
                data))
        super(EventNotFound, self).__init__(
            id='1024', message=message, data=data)


class EventFailedInterpolation(Event):
    """
    Event raised what an initial event message interpolation failed.
    """
    def __init__(self, event, bad_data):
        data = event.data.copy()
        data.update({
            'id': event.id,
            'message': event.message,
            'bad_data': bad_data,
            })
        message = (
            'Failed to resolve text for event id "%(id)s" and '
            'message "%(message)s" with data %(bad_data)s.' % (
                data))
        super(EventFailedInterpolation, self).__init__(
            id='1025', message=message, data=data)


EVENT_DEFAULTS = {
    'version_added': u'Disabled',
    'version_removed': u'Disabled',
    'description': u'None',
    }


class EventsDefinition(JSONFile):
    """
    Manages the definitions for Event and EventGroups.

    EventGroups and EventDefinitions are stored in a configuration file.
    """

    implements(IEventsDefinition)

    def __init__(self, path=None, file=None):
        super(EventsDefinition, self).__init__(path=path, file=file)
        self._group_definitions = {}
        self._event_definitions = {}

    def load(self):
        """
        See `IEventsDefinition`.
        """
        super(EventsDefinition, self).load()

        # Initialize empty file or if no group or events are defined.
        if not 'groups' in self.data:
            self.data['groups'] = {}
        if not 'events' in self.data:
            self.data['events'] = {}

        # First we must load the EventGroups and later EventDefinitions
        # as EventDefinitions depends on EventGroups.
        self._loadEventGroupDefinitions()
        self._loadEventDefinitions()

    def _loadEventGroupDefinitions(self):
        """
        Load all configured EventGroups.
        """
        for group_id, group_data in self.data['groups'].iteritems():

            name = group_id
            description = self.getValueOrNone(group_data, u'description')

            event_group = EventGroupDefinition(
                name=name, description=description)

            self._group_definitions[name] = event_group

    def _loadEventDefinitions(self):
        """
        Load all configured EventDefinitions.
        """
        for event_id, event_data in self.data['events'].iteritems():
            self._loadEventDefinition(
                event_id=event_id, event_data=event_data)

    def _loadEventDefinition(self, event_id, event_data):
        """
        Load a configured EventDefinition.
        """
        message = event_data['message']
        description = self.getValueOrNone(event_data, u'description')

        groups = []
        for group_name in event_data['groups']:
            group_name = group_name.strip()
            group = self.getEventGroupDefinition(name=group_name)
            groups.append(group)

        version_added = self.getValueOrNone(event_data, u'version_added')
        version_removed = self.getValueOrNone(event_data, u'version_removed')
        data = event_data['data']

        event_definition = EventDefinition(
            id=event_id,
            message=message,
            description=description,
            groups=groups,
            version_added=version_added,
            version_removed=version_removed,
            data=data,
            )

        self._event_definitions[event_definition.id] = event_definition

    def getEventDefinition(self, id):
        """
        See `IEventsDefinition`.
        """
        try:
            event_definition = self._event_definitions[id]
        except KeyError:
            raise ChevahException(
                _('No EventDefinition with id "%s"' % (id)))
        else:
            return event_definition

    def getAllEventDefinitions(self):
        """
        See `IEventsDefinition`.
        """
        return self._event_definitions.copy()

    def getAllEventDefinitionsPadded(self):
        """
        See `IEventsDefinition`.
        """
        result = {}
        for event_id, event in self._event_definitions.iteritems():
            result[event.id_padded] = event
        return result

    def getEventGroupDefinition(self, name):
        """
        See `IEventsDefinition`.
        """
        try:
            event_group = self._group_definitions[name]
        except KeyError:
            raise ChevahException(
                _('No EventGroupDefinition with name "%s"' % (name)))
        else:
            return event_group

    def getAllEventGroupDefinitions(self):
        """
        See `IEventsDefinition`.
        """
        return self._group_definitions.copy()

    def generateDocumentation(self, template):
        """
        See `IEventsDefinition`.
        """
        return template.render(
            groups=self.getAllEventGroupDefinitions(),
            events=self.getAllEventDefinitionsPadded(),
            )


class EventsHandler(object):

    def __init__(self):
        self._definitions = None
        self._log_configuration_section = None

    def configure(self, definitions, log_configuration_section):
        """
        Configure the events handler.
        """
        self._definitions = definitions
        self._log_configuration_section = log_configuration_section

    def removeConfiguration(self):
        """
        Remove all configuration for the handler.
        """
        self._definitions = None
        self._log_configuration_section = None

    @property
    def configured(self):
        """
        Return true if handler was configured.
        """
        if self._definitions and self._log_configuration_section:
            return True
        else:
            return False

    @property
    def definitions(self):
        """
        Return the EventDefinition and EventGroupDefinition database.
        """
        if not self._definitions:
            raise AssertionError('Event definitions are not yet defined.')
        return self._definitions

    @property
    def enabled_groups(self):
        """
        Return the commna separated string list of configured enabled groups
        for logging.
        """
        if not self._log_configuration_section:
            raise AssertionError(
                'Log configuration section is not yet defined.')
        return self._log_configuration_section.enabled_groups

    def emit(self, event_id, message=None, data=None):
        """
        Creates an event and calls emitEvent.

        This is here to make it easier to emit events and to not have to
        import event.Event in each file.
        """

        if isinstance(event_id, int):
            event_id = unicode(event_id)

        if isinstance(event_id, str):
            event_id = unicode(event_id)

        assert isinstance(event_id, basestring), (
            u'Emit id should be unicode or at least as string.')

        event = Event(
            id=event_id, message=message, data=data)
        return self.emitEvent(event)

    def log(self, message_id, text, avatar=None, peer=None, data=None):
        """
        An adapter from old log calls to the new emitEvent calls.

        All server logs were moved from Logger.log to EventsHandler.log.

        This is here for transitions and should be removed with the next
        refactoring.
        """
        if data is None:
            data = {}
        data.update({'peer': peer, 'avatar': avatar})
        event = Event(id=str(message_id), message=text, data=data)
        return self.emitEvent(event=event)

    def emitEvent(self, event):
        """
        Pefroms actions associated with event.

        Returns a deferred that fires when actions were finalized.
        """
        # When handler is not configured, we just log the message and stop.
        if not self.configured:
            self._logEvent(event)
            return defer.succeed(None)

        self.handleEventLog(event)
        self.handleEventAction(event)
        return defer.succeed(None)

    def handleEventLog(self, event):
        try:
            event_definition = self.definitions.getEventDefinition(event.id)
        except ChevahException:
            # FIXME:864:
            # Decide how to handle unknown events.
            # Maybe use a custom exception.
            # For now, we just log an error and stop
            self._logEvent(EventNotFound(event=event))
            return

        if self.isLogGroupEnabled(event_definition):
            self._logEvent(event=event, event_definition=event_definition)

    def _logEvent(self, event, event_definition=None):
        """
        Log the event.

        This is here mostly to help with tests.
        """
        def interpolate_message(message, data):
            try:
                result = message % data
            except KeyError:
                self._logEvent(EventFailedInterpolation(
                    event=event, bad_data=data))
                result = message
            return result

        if not event.message:
            if event_definition:
                message = event_definition.message
            elif 'message' in event.data:
                message = event.data['message']
            else:
                message = u'None'
            event.message = interpolate_message(message, event.data)

        try:
            peer = event.data['peer']
        except KeyError:
            peer = None

        try:
            avatar = event.data['avatar']
        except KeyError:
            avatar = None

        Logger.log(
            message_id=int(event.id),
            text=event.message,
            avatar=avatar,
            peer=peer,
            data=event.data,
            )

    def handleEventAction(self, event):
        """
        Perform associate actions for `event`.
        """
        # Will be implemented later.

    def isLogGroupEnabled(self, event_definition):
        """
        Return `True` if event_definition is enabled based on log groups.

        If 'all' is part of the groups, the event will be always enabled.
        """
        enabled_groups = self.enabled_groups
        if CONFIGURATION_ALL_LOG_ENABLED_GROUPS in enabled_groups:
            return True

        for group in event_definition.groups:
            if group.name in enabled_groups:
                return True
        return False
